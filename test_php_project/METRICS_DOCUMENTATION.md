# CodeRAG Metrics Documentation

Документация по метрикам, собираемым CodeRAG, и методам их поиска в тестовом проекте.

## Содержание

1. [Метрики сложности (Complexity Metrics)](#метрики-сложности)
2. [Цикломатическая сложность (Cyclomatic Complexity)](#цикломатическая-сложность)
3. [Когнитивная сложность (Cognitive Complexity)](#когнитивная-сложность)
4. [Проблемы безопасности (Security Issues)](#проблемы-безопасности)
5. [N+1 запросы (N+1 Queries)](#n1-запросы)
6. [Архитектурные метрики (Architecture Metrics)](#архитектурные-метрики)
7. [SOLID нарушения](#solid-нарушения)
8. [Паттерны проектирования](#паттерны-проектирования)
9. [DDD/MVC роли](#dddmvc-роли)

---

## Метрики сложности

### O(1) - Константная сложность

**Описание**: Время выполнения не зависит от размера входных данных.

**Где найти**:
- `Calculator::add()` - простое сложение двух чисел
- `User::getId()` - простой геттер
- `User::getEmail()` - доступ к свойству

**Как искать**: Методы без циклов, рекурсии и условных операторов, работающие с фиксированным количеством данных.

---

### O(log n) - Логарифмическая сложность

**Описание**: Время выполнения растет логарифмически с размером данных.

**Где найти**:
- `Calculator::binarySearch()` - бинарный поиск в отсортированном массиве

**Как искать**: Алгоритмы, которые делят проблему пополам на каждой итерации (бинарный поиск, бинарные деревья).

---

### O(n) - Линейная сложность

**Описание**: Время выполнения пропорционально размеру входных данных.

**Где найти**:
- `Calculator::sum()` - суммирование элементов массива
- `UserRepository::findAll()` - получение всех пользователей
- Линейный поиск в массивах

**Как искать**: Один цикл по входным данным без вложенных циклов.

---

### O(n²) - Квадратичная сложность

**Описание**: Время выполнения пропорционально квадрату размера данных.

**Где найти**:
- `Calculator::findDuplicates()` - поиск дубликатов с вложенными циклами
- `Calculator::findAllPairs()` - генерация всех пар элементов
- `Calculator::multiplyMatrices()` - умножение матриц (O(n³) для квадратных матриц)

**Как искать**: 
- Вложенные циклы: `for ($i = 0; $i < $n; $i++) { for ($j = 0; $j < $n; $j++) { ... } }`
- Сравнение каждого элемента с каждым
- Сортировка пузырьком, выбором

**Пример кода**:
```php
// O(n²) - вложенные циклы
for ($i = 0; $i < $n; $i++) {
    for ($j = $i + 1; $j < $n; $j++) {
        // сравнение элементов
    }
}
```

---

### O(n!) - Факториальная сложность

**Описание**: Время выполнения растет факториально с размером данных. Крайне неэффективно!

**Где найти**:
- `Calculator::generateAllPermutations()` - генерация всех перестановок

**Как искать**:
- Рекурсивные алгоритмы, генерирующие все возможные комбинации
- Генерация всех перестановок, комбинаций
- Некоторые алгоритмы решения задачи коммивояжера (brute force)

**Пример кода**:
```php
// O(n!) - генерация всех перестановок
function generateAllPermutations($items) {
    if (count($items) <= 1) {
        return [$items];
    }
    
    $permutations = [];
    for ($i = 0; $i < count($items); $i++) {
        // Рекурсивный вызов для каждого элемента
        $subPermutations = generateAllPermutations(/* остальные элементы */);
        // Объединение результатов
    }
    return $permutations;
}
```

**Предупреждение**: Для n=10 это 3,628,800 операций! Избегайте таких алгоритмов в продакшене.

---

## Цикломатическая сложность

**Описание**: Количество независимых путей выполнения в коде.

**Где найти**:

### Низкая (1-2)
- `Calculator::add()` - простые методы без условий
- Простые геттеры/сеттеры

### Средняя (3-5)
- Методы с несколькими `if`/`else`
- `UserService::registerUser()` - валидация с условиями

### Высокая (6+)
- Сложные методы с множественными условиями
- Большие `switch`/`case` блоки
- Методы с глубокой вложенностью условий

**Как искать**: Подсчитывайте количество точек принятия решений (if, else, switch, case, while, for, catch, &&, ||, ?:).

---

## Когнитивная сложность

**Описание**: Мера того, насколько сложно понять код человеку.

**Где найти**:
- `UserService::processUserAction()` - глубоко вложенные условия
- Методы с множественными уровнями вложенности
- Сложная логика с множественными `if` внутри `if`

**Как искать**: 
- Вложенность условий (if внутри if)
- Множественные условия в одном методе
- Сложная логика с множественными ответственностями

---

## Проблемы безопасности

### SQL Injection

**Где найти**:
- `UserRepository::findByNameUnsafe()` - прямое использование строк в SQL

**Как искать**:
```php
// ПЛОХО - SQL Injection
$query = "SELECT * FROM users WHERE name = '$name'";

// ХОРОШО - Prepared Statements
$stmt = $pdo->prepare("SELECT * FROM users WHERE name = ?");
$stmt->execute([$name]);
```

**Признаки**:
- Конкатенация строк в SQL запросах
- Использование `$variable` напрямую в SQL
- Отсутствие prepared statements

---

### XSS (Cross-Site Scripting)

**Где найти**:
- `EmailService::sendEmail()` - неэкранированный HTML в email

**Как искать**:
```php
// ПЛОХО - XSS уязвимость
echo "<div>" . $userInput . "</div>";

// ХОРОШО - экранирование
echo "<div>" . htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8') . "</div>";
```

**Признаки**:
- Вывод пользовательского ввода без экранирования
- Использование `innerHTML` в JavaScript
- Отсутствие валидации/санитизации входных данных

---

### Hardcoded Secrets

**Где найти**:
- `UserService::$apiKey` - захардкоженный API ключ

**Как искать**:
- Строковые константы с ключами, паролями, токенами
- API ключи в коде
- Пароли в конфигурационных файлах (если они в репозитории)

**Признаки**:
```php
// ПЛОХО
private $apiKey = 'sk-1234567890abcdef';

// ХОРОШО
private $apiKey = getenv('API_KEY');
```

---

## N+1 запросы

**Где найти**:
- `UserRepository::findUsersWithRoles()` - запросы в цикле

**Как искать**:
```php
// ПЛОХО - N+1 запросов
$users = $db->query("SELECT * FROM users")->fetchAll();
foreach ($users as $user) {
    $roles = $db->query("SELECT * FROM roles WHERE user_id = {$user->id}")->fetchAll();
    // N+1: 1 запрос для users + N запросов для roles
}

// ХОРОШО - 1 запрос с JOIN
$users = $db->query("
    SELECT u.*, r.name as role_name 
    FROM users u 
    LEFT JOIN user_roles ur ON u.id = ur.user_id 
    LEFT JOIN roles r ON ur.role_id = r.id
")->fetchAll();
```

**Признаки**:
- Запросы к БД внутри циклов
- Отдельные запросы для связанных данных
- Множественные запросы там, где можно использовать JOIN

---

## Архитектурные метрики

### God Object (Божественный объект)

**Где найти**:
- `UserService` - слишком много ответственностей

**Как искать**:
- Классы с большим количеством методов (10+)
- Классы, которые делают слишком много разных вещей
- Нарушение Single Responsibility Principle

**Признаки**:
- Класс управляет пользователями, отправляет email, валидирует данные, работает с БД
- Сложно понять, за что отвечает класс
- Высокое сцепление (coupling)

---

### Feature Envy (Зависть к функциональности)

**Где найти**:
- Методы, которые слишком часто обращаются к другому объекту

**Как искать**:
- Метод класса A часто вызывает методы класса B
- Метод больше работает с данными другого объекта, чем со своими

**Признаки**:
```php
// Метод в UserService, который слишком много работает с User
public function getUserInfo(User $user) {
    return $user->getName() . ' ' . $user->getEmail() . ' ' . $user->getPhone();
    // Должно быть в User::getInfo()
}
```

---

### Long Parameter List (Длинный список параметров)

**Где найти**:
- Методы с 5+ параметрами

**Как искать**:
- Методы с множественными параметрами
- Сложно запомнить порядок параметров
- Часто передаются связанные параметры вместе

**Решение**: Использовать объекты-параметры (Parameter Object pattern)

---

### Data Clumps (Скопления данных)

**Где найти**:
- Группы параметров, которые всегда передаются вместе

**Как искать**:
- Несколько параметров, которые всегда используются вместе
- Например: `$street, $city, $zipCode` - должны быть объектом `Address`

---

## SOLID нарушения

### Single Responsibility Principle (SRP)

**Где найти**:
- `UserService` - делает регистрацию, валидацию, отправку email, уведомления

**Как искать**:
- Класс имеет несколько причин для изменения
- Класс делает слишком много разных вещей

---

### Open/Closed Principle (OCP)

**Где найти**:
- Классы, которые нужно модифицировать для добавления новой функциональности

**Как искать**:
- Большие `if/else` или `switch` для обработки разных типов
- Невозможно расширить без изменения существующего кода

---

### Liskov Substitution Principle (LSP)

**Где найти**:
- Наследники, которые нарушают контракт родительского класса

**Как искать**:
- Подклассы, которые выбрасывают исключения, не ожидаемые родителем
- Подклассы, которые возвращают null там, где родитель возвращает объект

---

### Interface Segregation Principle (ISP)

**Где найти**:
- Интерфейсы с множеством методов, не все из которых нужны клиентам

**Как искать**:
- Классы, реализующие интерфейс, но не использующие все методы
- Большие интерфейсы, которые нужно разбить

---

### Dependency Inversion Principle (DIP)

**Где найти**:
- Прямые зависимости на конкретные классы вместо абстракций

**Как искать**:
- `new ConcreteClass()` вместо использования интерфейсов
- Жесткие зависимости на конкретные реализации

---

## Паттерны проектирования

### Singleton

**Где найти**:
- `DesignPatterns\Singleton` - единственный экземпляр класса

**Как искать**:
- Приватный конструктор
- Статический метод `getInstance()`
- Статическое свойство для хранения экземпляра

---

### Factory

**Где найти**:
- `DesignPatterns\Factory` - создание объектов через фабрику

**Как искать**:
- Методы, создающие объекты разных типов
- Централизованная логика создания объектов

---

### Repository

**Где найти**:
- `UserRepository` - абстракция доступа к данным

**Как искать**:
- Классы, инкапсулирующие доступ к данным
- Методы типа `find()`, `save()`, `delete()`

---

## DDD/MVC роли

### Model (Модель)

**Где найти**:
- `Models\User` - доменная сущность

**Как искать**:
- Классы, представляющие бизнес-сущности
- Содержат данные и бизнес-логику

---

### Repository (Репозиторий)

**Где найти**:
- `Repositories\UserRepository` - доступ к данным

**Как искать**:
- Классы для работы с хранилищем данных
- Абстракция над БД

---

### Service (Сервис)

**Где найти**:
- `Services\UserService` - бизнес-логика

**Как искать**:
- Классы, содержащие бизнес-логику
- Координируют работу между моделями и репозиториями

---

### Controller (Контроллер)

**Где найти**:
- `Controllers\UserController` - обработка HTTP запросов

**Как искать**:
- Классы, обрабатывающие HTTP запросы
- Координируют работу сервисов
- Возвращают ответы

---

## Как использовать эту документацию

1. **Для поиска проблем**: Используйте описание "Как искать" для каждого типа метрики
2. **Для понимания метрик**: Читайте описание и примеры кода
3. **Для рефакторинга**: Используйте примеры "ПЛОХО" и "ХОРОШО"

## Поиск в CodeRAG

После индексации проекта вы можете искать:

- **По сложности**: "найди методы с O(n²) сложностью"
- **По проблемам**: "покажи все SQL injection уязвимости"
- **По метрикам**: "найди методы с высокой цикломатической сложностью"
- **По паттернам**: "покажи все Singleton классы"

CodeRAG автоматически анализирует код и присваивает метрики каждой сущности.


